{
  "meta": {
    "projectName": "fat-controller",
    "version": "3.1.2",
    "lastUpdated": "2026-02-02",
    "description": "Architecture patterns, data flows, and component relationships"
  },
  "corePatterns": {
    "_comment": "Document the key architectural patterns used in your project",
    "authorityBasedMemory": {
      "description": "Single source of truth for each content type with strict routing",
      "keyFiles": [".ai/QUICK.md", ".ai/decisions/001-use-authority-based-memory.md"],
      "constraints": [
        "No content duplication across files",
        "QUICK.md is router only (no content)",
        "Each content type has ONE authoritative home"
      ],
      "benefits": [
        "Eliminates stale references",
        "Token efficiency through grep-first retrieval",
        "Clear ownership for updates",
        "Codex validation catches violations"
      ]
    },
    "commandAgentDelegation": {
      "description": "Commands handle Q&A, agents handle heavy generation work",
      "keyFiles": [".claude/commands/", ".claude/agents/"],
      "constraints": [
        "Commands run in main context (interactive)",
        "Agents run isolated (autonomous)",
        "Agents invoked via Task tool only"
      ],
      "benefits": [
        "Better context management",
        "Heavy work doesn't consume main conversation",
        "Clear separation of concerns"
      ]
    },
    "automatedCapture": {
      "description": "Commands automatically capture decisions, solutions, deprecations, tech debt",
      "keyFiles": [".claude/commands/prd.md", ".claude/commands/bugs.md", ".claude/commands/execute.md", ".claude/commands/code-review.md"],
      "constraints": [
        "Capture must not interrupt workflow",
        "Use YAML for solutions (grep-friendly)",
        "Use ADR format for decisions"
      ],
      "benefits": [
        "Builds knowledge base automatically",
        "Grep-first retrieval for faster debugging",
        "No manual documentation burden"
      ]
    },
    "templateSeparation": {
      "description": "Clean starter templates separated from active project memory",
      "keyFiles": ["templates/.ai/", "templates/tasks/", ".ai/"],
      "constraints": [
        "templates/.ai/ contains pristine starter files",
        ".ai/ contains active project memory",
        "Never sync templates/ during pull-fc (only .claude/)"
      ],
      "benefits": [
        "Easy project bootstrap from clean slate",
        "Active memory not polluted by examples",
        "Clear separation of starter vs working state"
      ]
    },
    "threeTierModelSelection": {
      "description": "Route tasks to appropriate model based on complexity and reasoning needs",
      "keyFiles": [".claude/commands/execute.md"],
      "constraints": [
        "Complexity 1-2: Codex (gpt-5.2-codex) with medium reasoning effort",
        "Complexity 3: Sonnet (Claude)",
        "Complexity 4-5: Codex (gpt-5.2-codex) with xhigh reasoning effort",
        "Use codex -c 'model_reasoning_effort=\"xhigh\"' for complex tasks"
      ],
      "benefits": [
        "Cost optimization via OpenAI token allocation for simple/complex tasks",
        "Claude tokens reserved for moderate complexity",
        "Deep reasoning for complex tasks without model switching"
      ]
    },
    "downstreamEffectsAnalysis": {
      "description": "Commands analyze ripple effects before implementation",
      "keyFiles": [".claude/commands/bugs.md", ".claude/commands/feature.md", ".claude/commands/prd.md"],
      "constraints": [
        "Must identify file:line of affected code",
        "Must assess likelihood (HIGH/MEDIUM/LOW)",
        "Integrated into exploration protocols",
        "Included in EXPLORE_CONTEXT handoff"
      ],
      "benefits": [
        "Prevents unintended consequences",
        "Identifies tests needing updates",
        "Maps consumers and dependents",
        "Informs risk assessment for fixes"
      ]
    },
    "debateOrchestration": {
      "description": "Multi-model debate for holistic decision analysis",
      "keyFiles": [".claude/commands/debate.md", ".claude/agents/debate-agent.md"],
      "constraints": [
        "3-round structured format (opening, cross-exam, cross-exam)",
        "Mandatory clarification phase before debate starts",
        "Parallel Round 1, sequential Rounds 2-3",
        "Orchestrator synthesizes, does not analyze",
        "Codex fallback to Claude-haiku on failure"
      ],
      "benefits": [
        "Multiple perspectives on complex decisions",
        "Natural model differences create thoroughness",
        "Cross-examination surfaces blind spots",
        "Structured output with actionable recommendations"
      ]
    },
    "dualModelCodeReview": {
      "description": "Parallel Claude and Codex code review with finding merge and deduplication",
      "keyFiles": [".claude/commands/code-review.md", ".claude/agents/code-review-agent.md"],
      "constraints": [
        "Both models output standardized JSON schema",
        "Deduplication uses hash(severity + category + location + first_50_chars_of_issue)",
        "Codex failure falls back to Claude-only mode",
        "Triage loop skips if --no-triage flag or fewer than 1 MEDIUM/LOW finding"
      ],
      "benefits": [
        "Maximizes finding coverage via dual perspectives",
        "Convergent findings have higher confidence (both models agree)",
        "Single-model findings surface unique insights",
        "User triage reduces noise (skip irrelevant findings)",
        "Source attribution in TECH_DEBT.md tracks which model flagged issue"
      ]
    },
    "_example": {
      "description": "Example: How services/managers are structured",
      "keyFiles": ["services/ExampleService.ext"],
      "constraints": ["Limitation 1", "Limitation 2"],
      "benefits": ["Benefit 1", "Benefit 2"]
    }
  },
  "layers": {
    "_comment": "Document your architectural layers (if using layered architecture)",
    "_example_presentation": {
      "description": "UI layer",
      "pattern": "MVVM / MVC / Component-based",
      "keyFiles": ["components/", "views/"]
    },
    "_example_business": {
      "description": "Business logic layer",
      "pattern": "Service classes / Managers / Use cases",
      "keyFiles": ["services/", "managers/", "use-cases/"]
    },
    "_example_data": {
      "description": "Data layer",
      "pattern": "Repository pattern / DAO",
      "keyFiles": ["repositories/", "models/"]
    }
  },
  "dataFlows": {
    "_comment": "Map how data moves through your system",
    "memoryUpdateFlow": {
      "name": "Memory system update workflow",
      "steps": [
        "User invokes /update command",
        "Update command launches update-memory-agent via Task tool",
        "Agent reads QUICK.md authority map",
        "Agent analyzes git diffs (last 10-20 commits)",
        "Agent routes updates to authoritative files",
        "Agent applies edits autonomously",
        "Codex validates authority rules (no duplication)",
        "Agent invokes /commit to push changes"
      ],
      "keyFiles": [
        ".claude/commands/update.md",
        ".claude/agents/update-memory-agent.md",
        ".codex/prompts/code-review.md"
      ],
      "dataModel": "Git diffs → Authority-routed edits → Validated memory files"
    },
    "codeReviewFlow": {
      "name": "Dual-model code review with parallel execution and automated tech debt capture",
      "steps": [
        "User invokes /code-review command",
        "Command spawns Claude (Opus) and Codex in parallel (default mode)",
        "Each model reviews git diffs independently and outputs JSON",
        "Findings merged with deduplication (hash-based matching)",
        "Convergent findings marked as source: both, confidence: convergent",
        "Single-model findings marked as source: claude|codex, confidence: single-model",
        "CRITICAL/HIGH findings → auto-fix with user approval",
        "MEDIUM/LOW findings → user triage loop (fix now, tech debt, skip)",
        "Deferred findings appended to TECH_DEBT.md with source attribution",
        "Command returns merged review summary with model breakdown"
      ],
      "keyFiles": [
        ".claude/commands/code-review.md",
        ".claude/agents/code-review-agent.md",
        ".codex/prompts/code-review.md",
        ".ai/TECH_DEBT.md"
      ],
      "dataModel": "Git diffs → Parallel JSON review (Claude + Codex) → Merge/deduplicate → Severity classification → Auto-fix OR triage → TECH_DEBT.md"
    },
    "debateFlow": {
      "name": "Multi-model debate for complex decision analysis",
      "steps": [
        "User invokes /debate [topic] command",
        "Command creates debates/{topic-slug}/ directory",
        "Optionally loads .ai/ context for project-related topics",
        "Clarification phase: ask 2-4 questions, lock brief.md",
        "Round 1 (parallel): Spawn Claude + Codex agents independently",
        "Write state.md with Round 1 responses",
        "Rounds 2-3 (sequential): Cross-examination with full history",
        "Append each round to state.md",
        "Synthesis phase: Orchestrator produces recommendations",
        "Assemble debate.md with all sections"
      ],
      "keyFiles": [
        ".claude/commands/debate.md",
        ".claude/agents/debate-agent.md",
        "debates/{topic-slug}/brief.md",
        "debates/{topic-slug}/state.md",
        "debates/{topic-slug}/debate.md"
      ],
      "dataModel": "Topic → Brief → 3 rounds (independent + cross-exam) → Synthesis → Actionable recommendations"
    },
    "_example": {
      "name": "User authentication flow",
      "steps": [
        "User submits credentials",
        "Validate credentials",
        "Generate token",
        "Store session",
        "Return to client"
      ],
      "keyFiles": ["services/auth/*.ext", "managers/TokenManager.ext"],
      "dataModel": "User + AuthToken"
    }
  },
  "integrationPoints": {
    "_comment": "Document how external systems integrate with your application",
    "_example_database": {
      "type": "PostgreSQL / MongoDB / Firebase / etc.",
      "pattern": "Repository pattern / ORM",
      "keyFiles": ["repositories/", "models/"]
    },
    "_example_externalAPIs": {
      "apis": ["API name 1", "API name 2"],
      "pattern": "HTTP client pattern / GraphQL client",
      "keyFiles": ["clients/ApiClient.ext"]
    }
  },
  "stateManagement": {
    "_comment": "Document your state management approach",
    "_example": {
      "pattern": "Redux / Vuex / Context API / State Manager",
      "keyFiles": ["store/index.ext", "StateManager.ext"],
      "stateTypes": ["Application state", "User state", "UI state"]
    }
  }
}
