{
  "meta": {
    "projectName": "fat-controller",
    "version": "4.0.0",
    "lastUpdated": "2026-02-21",
    "description": "Architecture patterns, data flows, and component relationships"
  },
  "corePatterns": {
    "_comment": "Document the key architectural patterns used in your project",
    "authorityBasedMemory": {
      "description": "Single source of truth for each content type with strict routing",
      "keyFiles": [".ai/QUICK.md", ".ai/decisions/001-use-authority-based-memory.md"],
      "constraints": [
        "No content duplication across files",
        "QUICK.md is router only (no content)",
        "Each content type has ONE authoritative home"
      ],
      "benefits": [
        "Eliminates stale references",
        "Token efficiency through grep-first retrieval",
        "Clear ownership for updates",
        "Codex validation catches violations"
      ]
    },
    "commandAgentDelegation": {
      "description": "Commands handle Q&A, agents handle heavy generation work",
      "keyFiles": [".claude/commands/", ".claude/agents/"],
      "constraints": [
        "Commands run in main context (interactive)",
        "Agents run isolated (autonomous)",
        "Agents invoked via Task tool only"
      ],
      "benefits": [
        "Better context management",
        "Heavy work doesn't consume main conversation",
        "Clear separation of concerns"
      ]
    },
    "automatedCapture": {
      "description": "Commands automatically capture decisions, solutions, deprecations, tech debt",
      "keyFiles": [".claude/commands/prd.md", ".claude/commands/bugs.md", ".claude/commands/execute.md", ".claude/commands/code-review.md"],
      "constraints": [
        "Capture must not interrupt workflow",
        "Use YAML for solutions (grep-friendly)",
        "Use ADR format for decisions"
      ],
      "benefits": [
        "Builds knowledge base automatically",
        "Grep-first retrieval for faster debugging",
        "No manual documentation burden"
      ]
    },
    "templateSeparation": {
      "description": "Clean starter templates separated from active project memory",
      "keyFiles": ["templates/.ai/", "templates/tasks/", ".ai/"],
      "constraints": [
        "templates/.ai/ contains pristine starter files",
        ".ai/ contains active project memory",
        "Never sync templates/ during pull-fc (only .claude/)"
      ],
      "benefits": [
        "Easy project bootstrap from clean slate",
        "Active memory not polluted by examples",
        "Clear separation of starter vs working state"
      ]
    },
    "threeTierModelSelection": {
      "description": "Route tasks to appropriate model based on complexity and reasoning needs",
      "keyFiles": [".claude/commands/execute.md"],
      "constraints": [
        "Complexity 1-2: Codex (gpt-5.2-codex) with medium reasoning effort",
        "Complexity 3: Sonnet (Claude)",
        "Complexity 4-5: Codex (gpt-5.2-codex) with xhigh reasoning effort",
        "Use codex -c 'model_reasoning_effort=\"xhigh\"' for complex tasks"
      ],
      "benefits": [
        "Cost optimization via OpenAI token allocation for simple/complex tasks",
        "Claude tokens reserved for moderate complexity",
        "Deep reasoning for complex tasks without model switching"
      ]
    },
    "downstreamEffectsAnalysis": {
      "description": "Commands analyze ripple effects before implementation",
      "keyFiles": [".claude/commands/bugs.md", ".claude/commands/feature.md", ".claude/commands/prd.md"],
      "constraints": [
        "Must identify file:line of affected code",
        "Must assess likelihood (HIGH/MEDIUM/LOW)",
        "Integrated into exploration protocols",
        "Included in EXPLORE_CONTEXT handoff"
      ],
      "benefits": [
        "Prevents unintended consequences",
        "Identifies tests needing updates",
        "Maps consumers and dependents",
        "Informs risk assessment for fixes"
      ]
    },
    "debateOrchestration": {
      "description": "Multi-model debate for holistic decision analysis",
      "keyFiles": [".claude/commands/debate.md", ".claude/agents/debate-agent.md"],
      "constraints": [
        "3-round structured format (opening, cross-exam, cross-exam)",
        "Mandatory clarification phase before debate starts",
        "Parallel Round 1, sequential Rounds 2-3",
        "Orchestrator synthesizes, does not analyze",
        "Codex fallback to Claude-haiku on failure"
      ],
      "benefits": [
        "Multiple perspectives on complex decisions",
        "Natural model differences create thoroughness",
        "Cross-examination surfaces blind spots",
        "Structured output with actionable recommendations"
      ]
    },
    "dualModelCodeReview": {
      "description": "Parallel Claude and Codex code review with finding merge and deduplication",
      "keyFiles": [".claude/commands/code-review.md", ".claude/agents/code-review-agent.md"],
      "constraints": [
        "Both models output standardized JSON schema",
        "Deduplication uses hash(severity + category + location + first_50_chars_of_issue)",
        "Codex failure falls back to Claude-only mode",
        "Triage loop skips if --no-triage flag or fewer than 1 MEDIUM/LOW finding"
      ],
      "benefits": [
        "Maximizes finding coverage via dual perspectives",
        "Convergent findings have higher confidence (both models agree)",
        "Single-model findings surface unique insights",
        "User triage reduces noise (skip irrelevant findings)",
        "Source attribution in TECH_DEBT.md tracks which model flagged issue"
      ]
    },
    "autonomousOrchestration": {
      "description": "Python orchestrator drives PM-PL autonomous execution cycles",
      "keyFiles": ["orchestrator.py", ".claude/agents/pm.md", ".claude/agents/pl.md", "templates/ROADMAP.md"],
      "constraints": [
        "Python 3 stdlib only (no pip dependencies)",
        "Filesystem is truth, sessions are disposable",
        "PM plans, PL executes, orchestrator loops",
        "YAML signals between ---ORCHESTRATOR_SIGNAL--- markers"
      ],
      "benefits": [
        "Autonomous PM-PL cycles without human intervention",
        "Structured state tracking in ROADMAP.md",
        "Parallel PL execution for independent sprints",
        "VALUES.md driven with graduated warning (not gate)",
        "Git branch per sprint with merge conflict handling"
      ]
    },
    "valuesDrivenAgentBoot": {
      "description": "Agents load ~/.claude/VALUES.md for decision-making, gracefully degrade if missing",
      "keyFiles": [".claude/agents/cto.md", ".claude/agents/pm.md", ".claude/agents/pl.md"],
      "constraints": [
        "VALUES.md is recommended but NOT required",
        "Graduated warning flow: check → recommend → confirm → confirm again → proceed",
        "Generic mode: conservative judgments, lower confidence threshold (~60% vs ~70%)"
      ],
      "benefits": [
        "Personalized decision-making aligned to user values",
        "Graceful degradation if VALUES.md missing",
        "No gatekeeping: user can proceed without values if desired",
        "Agents adapt behavior based on values presence"
      ]
    },
    "structuredOutputProtocol": {
      "description": "Agents output YAML signal blocks between ---ORCHESTRATOR_SIGNAL--- markers for orchestrator parsing",
      "keyFiles": ["orchestrator.py", ".claude/agents/pm.md", ".claude/agents/pl.md"],
      "constraints": [
        "Signal format: YAML between ---ORCHESTRATOR_SIGNAL--- markers",
        "Required fields: action (next_task, resume, completed, blocked, halt)",
        "PM signals: next_task, parallel_tasks, completed, blocked, halt",
        "PL signals: sprint_result with success/error status"
      ],
      "benefits": [
        "Reliable machine-parseable agent output",
        "Clear orchestrator control flow",
        "Structured error handling and blocking conditions",
        "Supports parallel task execution"
      ]
    },
    "graphEngineOrchestration": {
      "description": "DAG-based graph execution engine replacing linear PM-PL cycles. Nodes are typed (task, discovery, gate, fan_out, fan_in), executed via domain handlers, with per-node atomic checkpointing and resume.",
      "keyFiles": ["orchestrator.py", "model-stylesheet.yaml", ".claude/agents/discovery.md"],
      "constraints": [
        "Graph must be a valid DAG (no cycles) - validated at startup",
        "Node types: TASK, DISCOVERY, GATE, FAN_OUT, FAN_IN",
        "Context fidelity modes: MINIMAL (default), PARTIAL, FULL",
        "Domain types: SOFTWARE (default), CONTENT, MIXED",
        "Checkpoint written atomically via write-then-rename on every node state change",
        "Gate nodes use GoalGate evaluator with configurable acceptance criteria",
        "Goal gate failures trigger retry routing (up to max_retries) then escalation",
        "Model selection driven by model-stylesheet.yaml (not hardcoded in orchestrator)"
      ],
      "benefits": [
        "Resumable execution: restart from last checkpoint, not from scratch",
        "Domain-appropriate handlers (SoftwareHandler for code, ContentHandler for content, DiscoveryHandler for approach decisions)",
        "Provider-native invocation: claude CLI for Anthropic, codex CLI for OpenAI",
        "Model fallback chains defined in stylesheet per node class",
        "Adaptive discovery: simple vs complex mode based on complexity detection",
        "Goal gate convergence ensures quality before downstream nodes execute"
      ]
    },
    "modelStylesheetSystem": {
      "description": "External YAML file defines model provider, reasoning effort, and fallback chains per node class. Decouples model selection from orchestrator code.",
      "keyFiles": ["model-stylesheet.yaml"],
      "constraints": [
        "Node classes: planning, implementation, implementation-complex, review, gate, content-draft, discovery, discovery-simple, research, default",
        "Each class specifies: provider (anthropic|openai), model, reasoning_effort, tool_profile, timeout",
        "Fallback array: tried in order if primary provider fails",
        "tool_profile drives which CLI is used: claude for anthropic, codex for openai"
      ],
      "benefits": [
        "Model assignments changeable without touching orchestrator code",
        "Fallback chains provide resilience when providers are unavailable",
        "Separate planning vs implementation vs review model tiers",
        "Single file to tune performance/cost trade-offs"
      ]
    },
    "outcomesV2Pipeline": {
      "description": "6-phase state-machine for outcome discovery with XML phase tracking, resumability, parallel red-team dispatch, and interactive refinement",
      "keyFiles": [".claude/commands/outcomes.md"],
      "constraints": [
        "Phases: discovery, red-team, synthesis, context, refinement, finalize",
        "XML tracking enables resume from last completed phase",
        "Parallel red-team dispatch: multiple agents challenge outcomes concurrently",
        "outcomes.md is read-only to Project Lead (OUTCOMES.md is the output)"
      ],
      "benefits": [
        "Resumable if interrupted mid-phase",
        "Red-team phase surfaces blind spots and contradictions early",
        "Synthesis phase produces refined, measurable outcomes",
        "Finalize phase creates all state files (OUTCOMES.md, PROJECT_STATE.md, DECISIONS.md)"
      ]
    },
    "projectLeadOrchestration": {
      "description": "Project Lead agent drives sprints from outcomes to delivery using agent teams for parallel execution, protecting its own context window by delegating to sub-agents",
      "keyFiles": [".claude/commands/lead.md", ".claude/agents/project-lead.md"],
      "constraints": [
        "OUTCOMES.md is read-only for Project Lead (never modified)",
        "Must update PROJECT_STATE.md and DECISIONS.md after every state transition",
        "Escalation threshold: <70% confidence AND significant downside",
        "Uses TeamCreate for parallel workstreams when work supports it"
      ],
      "benefits": [
        "Context window protected by delegating heavy work to sub-agents",
        "Outcomes-driven: every sprint must map to an explicit outcome",
        "Decision authority framework prevents unnecessary interruptions to user",
        "State files (PROJECT_STATE.md, DECISIONS.md) provide audit trail"
      ]
    },
    "_example": {
      "description": "Example: How services/managers are structured",
      "keyFiles": ["services/ExampleService.ext"],
      "constraints": ["Limitation 1", "Limitation 2"],
      "benefits": ["Benefit 1", "Benefit 2"]
    }
  },
  "layers": {
    "_comment": "Document your architectural layers (if using layered architecture)",
    "_example_presentation": {
      "description": "UI layer",
      "pattern": "MVVM / MVC / Component-based",
      "keyFiles": ["components/", "views/"]
    },
    "_example_business": {
      "description": "Business logic layer",
      "pattern": "Service classes / Managers / Use cases",
      "keyFiles": ["services/", "managers/", "use-cases/"]
    },
    "_example_data": {
      "description": "Data layer",
      "pattern": "Repository pattern / DAO",
      "keyFiles": ["repositories/", "models/"]
    }
  },
  "dataFlows": {
    "_comment": "Map how data moves through your system",
    "memoryUpdateFlow": {
      "name": "Memory system update workflow",
      "steps": [
        "User invokes /update command",
        "Update command launches update-memory-agent via Task tool",
        "Agent reads QUICK.md authority map",
        "Agent analyzes git diffs (last 10-20 commits)",
        "Agent routes updates to authoritative files",
        "Agent applies edits autonomously",
        "Codex validates authority rules (no duplication)",
        "Agent invokes /commit to push changes"
      ],
      "keyFiles": [
        ".claude/commands/update.md",
        ".claude/agents/update-memory-agent.md",
        ".codex/prompts/code-review.md"
      ],
      "dataModel": "Git diffs → Authority-routed edits → Validated memory files"
    },
    "codeReviewFlow": {
      "name": "Dual-model code review with parallel execution and automated tech debt capture",
      "steps": [
        "User invokes /code-review command",
        "Command spawns Claude (Opus) and Codex in parallel (default mode)",
        "Each model reviews git diffs independently and outputs JSON",
        "Findings merged with deduplication (hash-based matching)",
        "Convergent findings marked as source: both, confidence: convergent",
        "Single-model findings marked as source: claude|codex, confidence: single-model",
        "CRITICAL/HIGH findings → auto-fix with user approval",
        "MEDIUM/LOW findings → user triage loop (fix now, tech debt, skip)",
        "Deferred findings appended to TECH_DEBT.md with source attribution",
        "Command returns merged review summary with model breakdown"
      ],
      "keyFiles": [
        ".claude/commands/code-review.md",
        ".claude/agents/code-review-agent.md",
        ".codex/prompts/code-review.md",
        ".ai/TECH_DEBT.md"
      ],
      "dataModel": "Git diffs → Parallel JSON review (Claude + Codex) → Merge/deduplicate → Severity classification → Auto-fix OR triage → TECH_DEBT.md"
    },
    "debateFlow": {
      "name": "Multi-model debate for complex decision analysis",
      "steps": [
        "User invokes /debate [topic] command",
        "Command creates debates/{topic-slug}/ directory",
        "Optionally loads .ai/ context for project-related topics",
        "Clarification phase: ask 2-4 questions, lock brief.md",
        "Round 1 (parallel): Spawn Claude + Codex agents independently",
        "Write state.md with Round 1 responses",
        "Rounds 2-3 (sequential): Cross-examination with full history",
        "Append each round to state.md",
        "Synthesis phase: Orchestrator produces recommendations",
        "Assemble debate.md with all sections"
      ],
      "keyFiles": [
        ".claude/commands/debate.md",
        ".claude/agents/debate-agent.md",
        "debates/{topic-slug}/brief.md",
        "debates/{topic-slug}/state.md",
        "debates/{topic-slug}/debate.md"
      ],
      "dataModel": "Topic → Brief → 3 rounds (independent + cross-exam) → Synthesis → Actionable recommendations"
    },
    "autonomousOrchestratorFlow": {
      "name": "Autonomous PM-PL execution cycle with git branch management and parallel execution",
      "steps": [
        "Orchestrator reads tasks/ROADMAP.md (sprint state)",
        "Invoke PM agent (claude --print --agent pm) to plan next sprint(s)",
        "PM signals next_task or parallel_tasks with sprint details",
        "Orchestrator creates git branch sprint/{sprint-name}",
        "Invoke PL agent (claude --print --agent pl) on branch with sprint PRD",
        "PL runs TaskGen → Execute → commits code → merges to main",
        "PL signals sprint_result (success/error) with summary",
        "Orchestrator updates ROADMAP.md with sprint status",
        "Loop: repeat PM → PL cycle until PM signals completed or blocked"
      ],
      "keyFiles": [
        "orchestrator.py",
        ".claude/agents/pm.md",
        ".claude/agents/pl.md",
        "tasks/ROADMAP.md",
        "tasks/OUTCOMES.md"
      ],
      "dataModel": "SprintState (name, target_outcome, status, prd_path, branch, pl_summary)"
    },
    "valuesDrivenBootFlow": {
      "name": "Values loading with graduated warning and graceful degradation",
      "steps": [
        "Agent starts, reads ~/.claude/VALUES.md",
        "If found: load values, adopt decision framework",
        "If NOT found: log WARNING, switch to generic mode",
        "Generic mode: conservative judgments, lower confidence threshold (~60%)",
        "Agent proceeds with work (no blocking gate)",
        "User sees warning on first run, can run /values-discovery if desired"
      ],
      "keyFiles": [
        ".claude/agents/cto.md",
        ".claude/agents/pm.md",
        ".claude/agents/pl.md",
        ".claude/commands/values-discovery.md",
        ".claude/commands/domain-values.md"
      ],
      "dataModel": "VALUES.md (optional, user-specific values profile)"
    },
    "orchestrateCommandFlow": {
      "name": "Orchestrate command pre-flight and tmux launch workflow",
      "steps": [
        "User invokes /orchestrate command",
        "Check 1: git repository exists",
        "Check 2: tasks/OUTCOMES.md exists (redirect to /outcomes if missing)",
        "Check 3: ~/.claude/VALUES.md exists (graduated warning, allow proceed)",
        "Check 4: tmux session 'orchestrator' exists (attach/kill/cancel)",
        "Launch: tmux new-session -d -s orchestrator with orchestrator.py",
        "Verify: tmux session started successfully",
        "Return: provide attach/monitor/shutdown instructions",
        "Session runs independently in background"
      ],
      "keyFiles": [
        ".claude/commands/orchestrate.md",
        "orchestrator.py",
        "tasks/OUTCOMES.md"
      ],
      "dataModel": "Tmux session running orchestrator.py → tasks/orchestrator.log"
    },
    "outcomesCommandFlow": {
      "name": "Outcomes command interactive discovery and state file initialization",
      "steps": [
        "User invokes /outcomes command",
        "Idempotency gate: check if OUTCOMES.md exists (review/fresh/cancel)",
        "Discovery Round 1: open context gathering (1 question)",
        "Discovery Round 2: extract and propose outcomes (1-3 questions)",
        "Discovery Round 3+: refinement until stopping criteria met",
        "Confirmation: summarize outcomes and wait for approval",
        "Create tasks/OUTCOMES.md (or overwrite if fresh start)",
        "Create tasks/PROJECT_STATE.md (if missing)",
        "Create tasks/DECISIONS.md (if missing)",
        "Optional: add Project Lead section to CLAUDE.md",
        "Offer to run /orchestrate command"
      ],
      "keyFiles": [
        ".claude/commands/outcomes.md",
        "tasks/OUTCOMES.md",
        "tasks/PROJECT_STATE.md",
        "tasks/DECISIONS.md",
        "CLAUDE.md"
      ],
      "dataModel": "Interactive Q&A → OUTCOMES.md + state files → optional orchestrate launch"
    },
    "graphEngineExecutionFlow": {
      "name": "Graph engine node execution with checkpointing and domain handlers",
      "steps": [
        "Orchestrator loads model-stylesheet.yaml and graph definition",
        "GraphEngine validates DAG (no cycles, all node refs exist)",
        "CheckpointManager loads or creates checkpoint.json for this run",
        "GraphEngine.get_ready_nodes() returns nodes with all deps completed",
        "For each ready node: select domain handler (Software/Content/Discovery)",
        "Handler selects model config from stylesheet by node class",
        "Provider-native invocation: claude CLI (Anthropic) or codex CLI (OpenAI)",
        "Node output parsed for ORCHESTRATOR_SIGNAL; outcome recorded to checkpoint",
        "GATE nodes: GoalGate evaluates acceptance criteria on upstream outcomes",
        "Gate failure: retry routing up to max_retries, then escalate",
        "Loop until all nodes completed, blocked, or failed"
      ],
      "keyFiles": [
        "orchestrator.py",
        "model-stylesheet.yaml",
        ".claude/agents/discovery.md"
      ],
      "dataModel": "Graph(nodes, edges, domain) → CheckpointState → NodeOutcome → final artifacts"
    },
    "leadCommandFlow": {
      "name": "Project Lead boot and orchestration flow",
      "steps": [
        "User invokes /lead command",
        "Load project-lead.md personality from ~/.claude/agents/",
        "Load OUTCOMES.md (required - halt if missing)",
        "Load or create PROJECT_STATE.md and DECISIONS.md",
        "Load .ai/QUICK.md for memory context (optional)",
        "Generate status briefing (PROJECT, OUTCOMES, CURRENT SPRINT, etc.)",
        "Determine NEXT ACTION from state decision tree",
        "Begin executing next action (sprint boundary, PRD, tasks, execution)",
        "Use TeamCreate for parallel workstreams to protect context window"
      ],
      "keyFiles": [
        ".claude/commands/lead.md",
        ".claude/agents/project-lead.md",
        "tasks/OUTCOMES.md",
        "tasks/PROJECT_STATE.md",
        "tasks/DECISIONS.md"
      ],
      "dataModel": "OUTCOMES.md + PROJECT_STATE.md + DECISIONS.md → sprint pipeline → delivered code"
    },
    "_example": {
      "name": "User authentication flow",
      "steps": [
        "User submits credentials",
        "Validate credentials",
        "Generate token",
        "Store session",
        "Return to client"
      ],
      "keyFiles": ["services/auth/*.ext", "managers/TokenManager.ext"],
      "dataModel": "User + AuthToken"
    }
  },
  "integrationPoints": {
    "_comment": "Document how external systems integrate with your application",
    "_example_database": {
      "type": "PostgreSQL / MongoDB / Firebase / etc.",
      "pattern": "Repository pattern / ORM",
      "keyFiles": ["repositories/", "models/"]
    },
    "_example_externalAPIs": {
      "apis": ["API name 1", "API name 2"],
      "pattern": "HTTP client pattern / GraphQL client",
      "keyFiles": ["clients/ApiClient.ext"]
    }
  },
  "stateManagement": {
    "_comment": "Document your state management approach",
    "_example": {
      "pattern": "Redux / Vuex / Context API / State Manager",
      "keyFiles": ["store/index.ext", "StateManager.ext"],
      "stateTypes": ["Application state", "User state", "UI state"]
    }
  }
}
