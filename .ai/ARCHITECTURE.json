{
  "meta": {
    "projectName": "fat-controller",
    "version": "3.3.1",
    "lastUpdated": "2026-02-14",
    "description": "Architecture patterns, data flows, and component relationships"
  },
  "corePatterns": {
    "_comment": "Document the key architectural patterns used in your project",
    "authorityBasedMemory": {
      "description": "Single source of truth for each content type with strict routing",
      "keyFiles": [".ai/QUICK.md", ".ai/decisions/001-use-authority-based-memory.md"],
      "constraints": [
        "No content duplication across files",
        "QUICK.md is router only (no content)",
        "Each content type has ONE authoritative home"
      ],
      "benefits": [
        "Eliminates stale references",
        "Token efficiency through grep-first retrieval",
        "Clear ownership for updates",
        "Codex validation catches violations"
      ]
    },
    "commandAgentDelegation": {
      "description": "Commands handle Q&A, agents handle heavy generation work",
      "keyFiles": [".claude/commands/", ".claude/agents/"],
      "constraints": [
        "Commands run in main context (interactive)",
        "Agents run isolated (autonomous)",
        "Agents invoked via Task tool only"
      ],
      "benefits": [
        "Better context management",
        "Heavy work doesn't consume main conversation",
        "Clear separation of concerns"
      ]
    },
    "automatedCapture": {
      "description": "Commands automatically capture decisions, solutions, deprecations, tech debt",
      "keyFiles": [".claude/commands/prd.md", ".claude/commands/bugs.md", ".claude/commands/execute.md", ".claude/commands/code-review.md"],
      "constraints": [
        "Capture must not interrupt workflow",
        "Use YAML for solutions (grep-friendly)",
        "Use ADR format for decisions"
      ],
      "benefits": [
        "Builds knowledge base automatically",
        "Grep-first retrieval for faster debugging",
        "No manual documentation burden"
      ]
    },
    "templateSeparation": {
      "description": "Clean starter templates separated from active project memory",
      "keyFiles": ["templates/.ai/", "templates/tasks/", ".ai/"],
      "constraints": [
        "templates/.ai/ contains pristine starter files",
        ".ai/ contains active project memory",
        "Never sync templates/ during pull-fc (only .claude/)"
      ],
      "benefits": [
        "Easy project bootstrap from clean slate",
        "Active memory not polluted by examples",
        "Clear separation of starter vs working state"
      ]
    },
    "threeTierModelSelection": {
      "description": "Route tasks to appropriate model based on complexity and reasoning needs",
      "keyFiles": [".claude/commands/execute.md"],
      "constraints": [
        "Complexity 1-2: Codex (gpt-5.2-codex) with medium reasoning effort",
        "Complexity 3: Sonnet (Claude)",
        "Complexity 4-5: Codex (gpt-5.2-codex) with xhigh reasoning effort",
        "Use codex -c 'model_reasoning_effort=\"xhigh\"' for complex tasks"
      ],
      "benefits": [
        "Cost optimization via OpenAI token allocation for simple/complex tasks",
        "Claude tokens reserved for moderate complexity",
        "Deep reasoning for complex tasks without model switching"
      ]
    },
    "downstreamEffectsAnalysis": {
      "description": "Commands analyze ripple effects before implementation",
      "keyFiles": [".claude/commands/bugs.md", ".claude/commands/feature.md", ".claude/commands/prd.md"],
      "constraints": [
        "Must identify file:line of affected code",
        "Must assess likelihood (HIGH/MEDIUM/LOW)",
        "Integrated into exploration protocols",
        "Included in EXPLORE_CONTEXT handoff"
      ],
      "benefits": [
        "Prevents unintended consequences",
        "Identifies tests needing updates",
        "Maps consumers and dependents",
        "Informs risk assessment for fixes"
      ]
    },
    "debateOrchestration": {
      "description": "Multi-model debate for holistic decision analysis",
      "keyFiles": [".claude/commands/debate.md", ".claude/agents/debate-agent.md"],
      "constraints": [
        "3-round structured format (opening, cross-exam, cross-exam)",
        "Mandatory clarification phase before debate starts",
        "Parallel Round 1, sequential Rounds 2-3",
        "Orchestrator synthesizes, does not analyze",
        "Codex fallback to Claude-haiku on failure"
      ],
      "benefits": [
        "Multiple perspectives on complex decisions",
        "Natural model differences create thoroughness",
        "Cross-examination surfaces blind spots",
        "Structured output with actionable recommendations"
      ]
    },
    "dualModelCodeReview": {
      "description": "Parallel Claude and Codex code review with finding merge and deduplication",
      "keyFiles": [".claude/commands/code-review.md", ".claude/agents/code-review-agent.md"],
      "constraints": [
        "Both models output standardized JSON schema",
        "Deduplication uses hash(severity + category + location + first_50_chars_of_issue)",
        "Codex failure falls back to Claude-only mode",
        "Triage loop skips if --no-triage flag or fewer than 1 MEDIUM/LOW finding"
      ],
      "benefits": [
        "Maximizes finding coverage via dual perspectives",
        "Convergent findings have higher confidence (both models agree)",
        "Single-model findings surface unique insights",
        "User triage reduces noise (skip irrelevant findings)",
        "Source attribution in TECH_DEBT.md tracks which model flagged issue"
      ]
    },
    "autonomousOrchestration": {
      "description": "Python orchestrator drives PM-PL autonomous execution cycles",
      "keyFiles": ["orchestrator.py", ".claude/agents/pm.md", ".claude/agents/pl.md", "templates/ROADMAP.md"],
      "constraints": [
        "Python 3 stdlib only (no pip dependencies)",
        "Filesystem is truth, sessions are disposable",
        "PM plans, PL executes, orchestrator loops",
        "YAML signals between ---ORCHESTRATOR_SIGNAL--- markers"
      ],
      "benefits": [
        "Autonomous PM-PL cycles without human intervention",
        "Structured state tracking in ROADMAP.md",
        "Parallel PL execution for independent sprints",
        "VALUES.md driven with graduated warning (not gate)",
        "Git branch per sprint with merge conflict handling"
      ]
    },
    "valuesDrivenAgentBoot": {
      "description": "Agents load ~/.claude/VALUES.md for decision-making, gracefully degrade if missing",
      "keyFiles": [".claude/agents/cto.md", ".claude/agents/pm.md", ".claude/agents/pl.md"],
      "constraints": [
        "VALUES.md is recommended but NOT required",
        "Graduated warning flow: check → recommend → confirm → confirm again → proceed",
        "Generic mode: conservative judgments, lower confidence threshold (~60% vs ~70%)"
      ],
      "benefits": [
        "Personalized decision-making aligned to user values",
        "Graceful degradation if VALUES.md missing",
        "No gatekeeping: user can proceed without values if desired",
        "Agents adapt behavior based on values presence"
      ]
    },
    "structuredOutputProtocol": {
      "description": "Agents output YAML signal blocks between ---ORCHESTRATOR_SIGNAL--- markers for orchestrator parsing",
      "keyFiles": ["orchestrator.py", ".claude/agents/pm.md", ".claude/agents/pl.md"],
      "constraints": [
        "Signal format: YAML between ---ORCHESTRATOR_SIGNAL--- markers",
        "Required fields: action (next_task, resume, completed, blocked, halt)",
        "PM signals: next_task, parallel_tasks, completed, blocked, halt",
        "PL signals: sprint_result with success/error status"
      ],
      "benefits": [
        "Reliable machine-parseable agent output",
        "Clear orchestrator control flow",
        "Structured error handling and blocking conditions",
        "Supports parallel task execution"
      ]
    },
    "_example": {
      "description": "Example: How services/managers are structured",
      "keyFiles": ["services/ExampleService.ext"],
      "constraints": ["Limitation 1", "Limitation 2"],
      "benefits": ["Benefit 1", "Benefit 2"]
    }
  },
  "layers": {
    "_comment": "Document your architectural layers (if using layered architecture)",
    "_example_presentation": {
      "description": "UI layer",
      "pattern": "MVVM / MVC / Component-based",
      "keyFiles": ["components/", "views/"]
    },
    "_example_business": {
      "description": "Business logic layer",
      "pattern": "Service classes / Managers / Use cases",
      "keyFiles": ["services/", "managers/", "use-cases/"]
    },
    "_example_data": {
      "description": "Data layer",
      "pattern": "Repository pattern / DAO",
      "keyFiles": ["repositories/", "models/"]
    }
  },
  "dataFlows": {
    "_comment": "Map how data moves through your system",
    "memoryUpdateFlow": {
      "name": "Memory system update workflow",
      "steps": [
        "User invokes /update command",
        "Update command launches update-memory-agent via Task tool",
        "Agent reads QUICK.md authority map",
        "Agent analyzes git diffs (last 10-20 commits)",
        "Agent routes updates to authoritative files",
        "Agent applies edits autonomously",
        "Codex validates authority rules (no duplication)",
        "Agent invokes /commit to push changes"
      ],
      "keyFiles": [
        ".claude/commands/update.md",
        ".claude/agents/update-memory-agent.md",
        ".codex/prompts/code-review.md"
      ],
      "dataModel": "Git diffs → Authority-routed edits → Validated memory files"
    },
    "codeReviewFlow": {
      "name": "Dual-model code review with parallel execution and automated tech debt capture",
      "steps": [
        "User invokes /code-review command",
        "Command spawns Claude (Opus) and Codex in parallel (default mode)",
        "Each model reviews git diffs independently and outputs JSON",
        "Findings merged with deduplication (hash-based matching)",
        "Convergent findings marked as source: both, confidence: convergent",
        "Single-model findings marked as source: claude|codex, confidence: single-model",
        "CRITICAL/HIGH findings → auto-fix with user approval",
        "MEDIUM/LOW findings → user triage loop (fix now, tech debt, skip)",
        "Deferred findings appended to TECH_DEBT.md with source attribution",
        "Command returns merged review summary with model breakdown"
      ],
      "keyFiles": [
        ".claude/commands/code-review.md",
        ".claude/agents/code-review-agent.md",
        ".codex/prompts/code-review.md",
        ".ai/TECH_DEBT.md"
      ],
      "dataModel": "Git diffs → Parallel JSON review (Claude + Codex) → Merge/deduplicate → Severity classification → Auto-fix OR triage → TECH_DEBT.md"
    },
    "debateFlow": {
      "name": "Multi-model debate for complex decision analysis",
      "steps": [
        "User invokes /debate [topic] command",
        "Command creates debates/{topic-slug}/ directory",
        "Optionally loads .ai/ context for project-related topics",
        "Clarification phase: ask 2-4 questions, lock brief.md",
        "Round 1 (parallel): Spawn Claude + Codex agents independently",
        "Write state.md with Round 1 responses",
        "Rounds 2-3 (sequential): Cross-examination with full history",
        "Append each round to state.md",
        "Synthesis phase: Orchestrator produces recommendations",
        "Assemble debate.md with all sections"
      ],
      "keyFiles": [
        ".claude/commands/debate.md",
        ".claude/agents/debate-agent.md",
        "debates/{topic-slug}/brief.md",
        "debates/{topic-slug}/state.md",
        "debates/{topic-slug}/debate.md"
      ],
      "dataModel": "Topic → Brief → 3 rounds (independent + cross-exam) → Synthesis → Actionable recommendations"
    },
    "autonomousOrchestratorFlow": {
      "name": "Autonomous PM-PL execution cycle with git branch management and parallel execution",
      "steps": [
        "Orchestrator reads tasks/ROADMAP.md (sprint state)",
        "Invoke PM agent (claude --print --agent pm) to plan next sprint(s)",
        "PM signals next_task or parallel_tasks with sprint details",
        "Orchestrator creates git branch sprint/{sprint-name}",
        "Invoke PL agent (claude --print --agent pl) on branch with sprint PRD",
        "PL runs TaskGen → Execute → commits code → merges to main",
        "PL signals sprint_result (success/error) with summary",
        "Orchestrator updates ROADMAP.md with sprint status",
        "Loop: repeat PM → PL cycle until PM signals completed or blocked"
      ],
      "keyFiles": [
        "orchestrator.py",
        ".claude/agents/pm.md",
        ".claude/agents/pl.md",
        "tasks/ROADMAP.md",
        "tasks/OUTCOMES.md"
      ],
      "dataModel": "SprintState (name, target_outcome, status, prd_path, branch, pl_summary)"
    },
    "valuesDrivenBootFlow": {
      "name": "Values loading with graduated warning and graceful degradation",
      "steps": [
        "Agent starts, reads ~/.claude/VALUES.md",
        "If found: load values, adopt decision framework",
        "If NOT found: log WARNING, switch to generic mode",
        "Generic mode: conservative judgments, lower confidence threshold (~60%)",
        "Agent proceeds with work (no blocking gate)",
        "User sees warning on first run, can run /values-discovery if desired"
      ],
      "keyFiles": [
        ".claude/agents/cto.md",
        ".claude/agents/pm.md",
        ".claude/agents/pl.md",
        ".claude/commands/values-discovery.md",
        ".claude/commands/domain-values.md"
      ],
      "dataModel": "VALUES.md (optional, user-specific values profile)"
    },
    "orchestrateCommandFlow": {
      "name": "Orchestrate command pre-flight and tmux launch workflow",
      "steps": [
        "User invokes /orchestrate command",
        "Check 1: git repository exists",
        "Check 2: tasks/OUTCOMES.md exists (redirect to /outcomes if missing)",
        "Check 3: ~/.claude/VALUES.md exists (graduated warning, allow proceed)",
        "Check 4: tmux session 'orchestrator' exists (attach/kill/cancel)",
        "Launch: tmux new-session -d -s orchestrator with orchestrator.py",
        "Verify: tmux session started successfully",
        "Return: provide attach/monitor/shutdown instructions",
        "Session runs independently in background"
      ],
      "keyFiles": [
        ".claude/commands/orchestrate.md",
        "orchestrator.py",
        "tasks/OUTCOMES.md"
      ],
      "dataModel": "Tmux session running orchestrator.py → tasks/orchestrator.log"
    },
    "outcomesCommandFlow": {
      "name": "Outcomes command interactive discovery and state file initialization",
      "steps": [
        "User invokes /outcomes command",
        "Idempotency gate: check if OUTCOMES.md exists (review/fresh/cancel)",
        "Discovery Round 1: open context gathering (1 question)",
        "Discovery Round 2: extract and propose outcomes (1-3 questions)",
        "Discovery Round 3+: refinement until stopping criteria met",
        "Confirmation: summarize outcomes and wait for approval",
        "Create tasks/OUTCOMES.md (or overwrite if fresh start)",
        "Create tasks/PROJECT_STATE.md (if missing)",
        "Create tasks/DECISIONS.md (if missing)",
        "Optional: add Project Lead section to CLAUDE.md",
        "Offer to run /orchestrate command"
      ],
      "keyFiles": [
        ".claude/commands/outcomes.md",
        "tasks/OUTCOMES.md",
        "tasks/PROJECT_STATE.md",
        "tasks/DECISIONS.md",
        "CLAUDE.md"
      ],
      "dataModel": "Interactive Q&A → OUTCOMES.md + state files → optional orchestrate launch"
    },
    "_example": {
      "name": "User authentication flow",
      "steps": [
        "User submits credentials",
        "Validate credentials",
        "Generate token",
        "Store session",
        "Return to client"
      ],
      "keyFiles": ["services/auth/*.ext", "managers/TokenManager.ext"],
      "dataModel": "User + AuthToken"
    }
  },
  "integrationPoints": {
    "_comment": "Document how external systems integrate with your application",
    "_example_database": {
      "type": "PostgreSQL / MongoDB / Firebase / etc.",
      "pattern": "Repository pattern / ORM",
      "keyFiles": ["repositories/", "models/"]
    },
    "_example_externalAPIs": {
      "apis": ["API name 1", "API name 2"],
      "pattern": "HTTP client pattern / GraphQL client",
      "keyFiles": ["clients/ApiClient.ext"]
    }
  },
  "stateManagement": {
    "_comment": "Document your state management approach",
    "_example": {
      "pattern": "Redux / Vuex / Context API / State Manager",
      "keyFiles": ["store/index.ext", "StateManager.ext"],
      "stateTypes": ["Application state", "User state", "UI state"]
    }
  }
}
